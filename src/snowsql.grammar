@top SnowSQL {Expr}

@precedence {
  pow @right,
  mul @left,
  add @left,
  eql @left,
  and @left,
  or @left
}


Expr {
  SelectExpr |
  CreateExpr|
  DescribeExpr |
  DropExpr|
 //BinaryExpr |
  NumberLiteral |
  ParenExpr |
  StringLiteral |
  SubqueryExpr |
  UnaryExpr 
  }

/*

BinaryExpr {
  Expr !pow Pow    BinModifiers Expr |
  Expr !mul Mul    BinModifiers Expr |
  Expr !mul Div    BinModifiers Expr |
  Expr !mul Mod    BinModifiers Expr |
  Expr !add Add    BinModifiers Expr |
  Expr !add Sub    BinModifiers Expr |
  
  Expr !eql Eql    BinModifiers Expr |
  Expr !eql Gte    BinModifiers Expr |
  Expr !eql Gtr    BinModifiers Expr |
  Expr !eql Lte    BinModifiers Expr |
  Expr !eql Lss    BinModifiers Expr |
  Expr !eql Neq    BinModifiers Expr |
  Expr !and And    BinModifiers Expr |
  Expr !or  Or     BinModifiers Expr
  
}
*/

OnOrIgnoring {
  Ignoring GroupingLabels |
  On GroupingLabels
}

BinModifiers {
  Bool?
  (
    OnOrIgnoring
    (
      (GroupLeft | GroupRight)
      (!mul GroupingLabels)? // TODO: Is the "!mul" here correct? Inserted it to resolve a shift/reduce conflict because we always want to count opening parenthesis after this to be counted toward this modifier, not toward a next sub-expression.
    )?
  )?
}

GroupingLabels {
  "(" GroupingLabelList ")" |
  "(" GroupingLabelList "," ")" |
  "(" ")"
}

GroupingLabelList {
  GroupingLabelList "," GroupingLabel |
  GroupingLabel
}

//@skip { whitespace | LineComment }


GroupingLabel {
  LabelName
}



ParenExpr {
  "(" Expr ")"
}


SelectExpr{
  //( Identifier "," Identifier )  |( Identifier (Identifier ",")* Identifier )  | 

  // Select whitespace  (Mul | Identifier| Identifier+(Smc Identifier+)*) whitespace From whitespace Identifier  Smc |

  //Select whitespace Mul whitespace  From whitespace  Identifier Smc |

  //Select whitespace Mul whitespace  From whitespace  Identifier Smc |

  //Select whitespace  "(" ArithExpr ")" Smc|

  Select whitespace   "("? NumberLiteral whitespace  Add whitespace NumberLiteral  ")"?  Smc |
  
  Select whitespace   (    Mul  | ((Identifier)(Comma Identifier)*)) whitespace From whitespace  Identifier Smc 

  // Select whitespace (Mul | Identifier | "," )+  whitespace From whitespace Identifier whitespace Where (whitespace| Identifier | "," )+ (">=" | "<=" | "!=" | ">" | "<") Identifier Smc
}


 
CreateExpr{

  // Create whitespace Account (whitespace)? Identifier Admin "-" Name (whitespace)? "=" (whitespace)? Identifier whitespace Admin Dash Password (whitespace)? "=" (whitespace)? "'" Identifier "'"  whitespace Email (whitespace)? "=" (whitespace)? Identifier whitespace Edition (whitespace)? "=" (whitespace)? (Standard|Enterprise|Business "-" Edition) AccountOptional ";"

  Create whitespace Account (whitespace) Identifier Admin "-" Name (whitespace) "=" (whitespace)? Identifier whitespace Admin Dash Password (whitespace)? "=" (whitespace)? "'" Identifier "'" whitespace Email (whitespace)? "=" (whitespace) Identifier whitespace Edition (whitespace)? "=" (whitespace) (Standard |Enterprise |Business "-" Critical) (First "-" Name (whitespace)?"="(whitespace) Identifier)?(Last "-" Name (whitespace)?"="(whitespace) Identifier) (Must "-" Change "-" Password(whitespace)?"="(whitespace) (True|False) ) ";"
  
  //(Create whitespace Account (whitespace)? Identifier Admin "-" Name (whitespace)? "=" (whitespace)? Identifier whitespace Admin Dash Password (whitespace)? "=" (whitespace)? "'" Identifier "'"  whitespace Email (whitespace)? "=" (whitespace)? Identifier whitespace Edition (whitespace)? "=" (whitespace)? (Standard|Enterprise|Business "-" Edition) AccountOptional ";")

  //Create whitespace Network whitespace Policy whitespace Identifier whitespace Allowed whitespace* "-"  whitespace*  IP   whitespace* "-"  whitespace* List EqlSingle Opl (whitespace)? Sqt Identifier (whitespace)? Sqt Opr  (Blocked_IP_Policy EqlSingle Opl (whitespace)? Sqt Identifier (whitespace)? Sqt Opr)?Smc|
  
  // Create whitespace Account (whitespace)? Identifier Admin "-" Name (whitespace)? "=" (whitespace)? Identifier whitespace Admin Dash Password (whitespace)? "=" (whitespace)? "'" Identifier "'"  whitespace Email (whitespace)? "=" (whitespace)? Identifier whitespace Edition (whitespace)? "=" (whitespace)? (Standard |Enterprise |Business "-" Critical) (First "-" Name (whitespace)?"="(whitespace)?  Identifier)? (Must "-" Change "-" Password(whitespace)?"="(whitespace)? (True|False) )? ";" 

  //Create whitespace Managed whitespace Account whitespace Identifier Admin"-"Name (whitespace)? "=" (whitespace)? Admin"-"Password

}



DropExpr{

  Drop whitespace (Table|User) whitespace Identifier Smc
  //Drop whitespace Table whitespace If 

}

DescribeExpr{

  (Describe | Desc) whitespace Table whitespace Identifier ( whitespace Type whitespace EqlSingle whitespace (Stage| Columns )*)? Smc|
  (Describe | Desc) whitespace Table whitespace Identifier Smc |
  (Describe | Desc) whitespace View whitespace Identifier Smc |
  (Describe | Desc) whitespace User whitespace Identifier Smc |
  (Describe | Desc) whitespace Network whitespace Policy whitespace Identifier Smc
  
}

SubqueryExpr {
  Expr "[" Duration ":" ("" | Duration) "]"
}

UnaryExpr {
  !mul UnaryOp Expr
}

UnaryOp {
  "-" |
  "+"
}


LabelMatchers {
  "{" LabelMatchList "}" |
  "{" LabelMatchList "," "}" |
  "{" "}"
}

LabelMatchList {
  LabelMatchList "," LabelMatcher |
  LabelMatcher
}

MatchOp {
  EqlSingle |
  Neq |
  EqlRegex |
  NeqRegex
}

LabelMatcher {
  LabelName MatchOp StringLiteral
}

MetricIdentifier {
  Identifier
}

StepInvariantExpr {
  Expr At ( NumberLiteral | SignedNumber | AtModifierPreprocessors "(" ")" )
}

AtModifierPreprocessors {
  Start | End
}

SignedNumber{
  ("+" | "-" ) NumberLiteral
}

//@skip { whitespace | LineComment }

@tokens {
  whitespace { std.whitespace+ }
  LineComment { "#" ![\n]* }

  NumberLiteral {
   // ("+" | "-")? 
    (
      (std.digit+ ("." std.digit*)? | "." std.digit+) (("e" | "E") ("+" | "-")? std.digit+)? |
      "0x" (std.digit | $[a-fA-F])+ |
      $[nN]$[aA]$[nN] |
      $[iI]$[nN]$[fF]
    )
  }
  StringLiteral { // TODO: This is for JS, make this work for PromQL.
    '"' (![\\\n"] | "\\" _)* '"'? |
    "'" (![\\\n'] | "\\" _)* "'"? |
    "`" ![`]* "`"
  }

  Duration {
    // Each line below is just the same regex repeated over and over, but each time with one of the units made non-optional,
    // to ensure that at least one <number>+<unit> pair is provided and an empty string is not recognized as a valid duration.
    ( ( std.digit+ "y" ) ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" ) ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" ) ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" ) ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" ) ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" ) ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" ) )
  }
  Identifier { (std.asciiLetter | "_" | ":") (std.asciiLetter | std.digit | "_" | ":" )*}
  LabelName { (std.asciiLetter | "_") (std.asciiLetter | std.digit | "_")* }

  // Operator
  Smc {";"}
  Uscr {"_"}
  Dash {"-"}
  //Star {"*"}
  Sub { "-" }
  Add { "+" }
  Mul { "*" }
  Mod { "%" }
  Div { "/" }
  Eql { "==" }
  Neq { "!=" }
  Lte { "<=" }
  Lss { "<" }
  Gte { ">=" }
  Gtr { ">" }
  Sqt {"'"}
  EqlRegex { "=~" }
  EqlSingle { "=" }
  NeqRegex { "!~" }
  Pow { "^" }
  Opl {"("}
  Opr {")"}


  //SQL
  Comma {","}

  // Special Modifier
  At { "@" }

  // Modifier Preprocessors
  Start { "start" }
  End { "end" }

  // To parse signed numbers into a number literal and not a unary expression.
  @precedence { NumberLiteral, "+", "-" }
  // To parse NaN/Inf as a number literal.
  @precedence { NumberLiteral, Identifier }
}


/*
ArithExpr{
  NumberLiteral Sub|Add NumberLiteral
}*/




// Keywords

@external specialize {Identifier} specializeIdentifier from "./tokens" {
  Bool,
  Ignoring,
  On,
  GroupLeft,
  GroupRight,
  Offset,
  Account,
  Name,
  Password,
  Email,
  Admin,
  Edition,
  Standard
  Enterprise,
  Business,
  Critical,
  First,
  Last,
  Must,
  Change,
  True ,
  False,
  From,
  Select,
  List,
  Drop,
  Schema,
  Cascade,
  Restrict,
  Task,
  Role,
  Warehouse,
  File,
  Format,
  If,
  Exists,
  Allowed,
  IP,
  Blocked_IP_Policy,
  Allowed_IP_Policy,
  Columns,
  Create,
  Policy,
  Type,
  Stage,
  Where,
  Desc,
  View,
  User,
  Describe,
  Table,
  Network
}

// Contextual keywords

@external extend {Identifier} extendIdentifier from "./tokens" {

 
  Count,
  Group,
  By,
  And,
  Or
  
}

