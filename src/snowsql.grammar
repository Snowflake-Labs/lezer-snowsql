// Entry point of the grammar.
@top SnowSQL {Expr+}
// The precedence order
@precedence {
  pow @right,
  mul @left,
  add @left,
  eql @left,
  and @left,
  or @left
}
// Expr is the parent node
Expr {
  NumberLiteral |
  ParenExpr |
  StringLiteral |
  SubqueryExpr |
  UnaryExpr |
  Stmt //We wanted to refer to our constructs as statements however we have not yet removed all of the promql construts a
  //nd most of them refer to expr as the parent node so we made stmt a child node of expr but the parent node for all our defnitions. 
  }

//Parent node for our statement constructs
Stmt {
  SelectStmt | // The logic for the select statement will be here. 
  CreateStmt| //create statement
  DescribeStmt | //describe statement.
  DropStmt //Drop statement.

}



OnOrIgnoring {
  Ignoring GroupingLabels |
  On GroupingLabels
}

BinModifiers {
  Bool?
  (
    OnOrIgnoring
    (
      (GroupLeft | GroupRight)
      (!mul GroupingLabels)? // TODO: Is the "!mul" here correct? Inserted it to resolve a shift/reduce conflict because we always want to count opening parenthesis after this to be counted toward this modifier, not toward a next sub-expression.
    )?
  )?
}

GroupingLabels {
  "(" GroupingLabelList ")" |
  "(" GroupingLabelList "," ")" |
  "(" ")"
}

GroupingLabelList {
  GroupingLabelList "," GroupingLabel |
  GroupingLabel
}




GroupingLabel {
  LabelName
}
//This is where the select statement is defined currently it only supports the from and where clause. 
SelectStmt{
  Select  (Mul  | ((Identifier)(Comma Identifier)*))  
  From  Identifier  (Where Identifier WhereOp)? Smc 
}

WhereOp
{
((Not)? Between (Identifier|NumberLiteral) And (Identifier|NumberLiteral) ) | //For between 
(In Identifier ("," Identifier)* ) |  // For in 
(Like Identifier (Escape Identifier)? ) |  //or for like 
(  (Null|  (Not)? Identifier Is Null)    ) | //For  Null and not Null
( (Not)? Identifier ((And|Or|Not) Identifier)+)  // For the logical operators
}
 
InOp
{
( Identifier (Not)? In Identifier ("," Identifier)* )?
}

LikeOp
{
(Identifier (Not)? Like Identifier Escape Identifier)?
}

NullOp
{
( (Identifier Is (Not)? Null)| ( (Not)? Identifier Is Null) )?
}

LogicOp
{
( (Not)? Identifier ((And|Or|Not) Identifier)+)?          
}
// Create statement currently supports create account 
CreateStmt{

  Create Account Identifier       Admin_name EqlSingle Identifier       Admin_password EqlSingle Sqt Identifier  Cqt  ( First_name EqlSingle Identifier )? ( Last_name EqlSingle Identifier )?
  Email EqlSingle Identifier     ( Must_change_password EqlSingle ( True | False ) )? Edition EqlSingle ( Standard | Enterprise | Business_critical ) AccountOptional Smc |
  

  Create ( Or Replace )? Api Integration ( If Not Exists )? Identifier     Api_provider "=" ( Aws_api_gateway | Aws_private_api_gateway )
    Api_aws_role_arn "="  Identifier 
    Api_allowed_prefixes "=" Opl Identifier Opr
    ( Api_blocked_prefixes "=" "(" Identifier ")" )?
    Enabled "=" ( True | False )
    ( Comment "="  Identifier  )? ";" |
//create file format
Create ( Or Replace )? ( Stage | File Format | Sequence | Task ) ( If Not Exists )? Identifier   Clone Identifier     ";" |

//create database
Create ( Or Replace )? ( Transient )? Database ( If Not Exists )? Identifier     
( Clone Identifier           ( ( At | Before ) ( ( Timestamp "=" Identifier | Offset "=" Identifier | Statement "=" Identifier ) ) )? )?
 DbOp
  ";" | 
  Create Database Identifier From Share Identifier Dot Identifier     ";" |
  Create Database Identifier     As Replica Of Identifier  "." Identifier
    Auto_refresh_materialized_views_on_secondary "=" ( True | False )
    ";" |
//create network policy
  Create  Network  Policy  Identifier  Allowed_IP_List EqlSingle Opl   Sqt Identifier   Sqt Opr  (Blocked_IP_List EqlSingle Opl   Sqt Identifier   Sqt Opr)?Smc |
// create external function
  Create ( Or Replace )? ( Secure )? External Function Identifier ( "(" Identifier ")" )? 
  Returns Identifier ( Null |Not  Null )?  
  ExFOp1
  Api_integration "=" Identifier   
  ExFOp2
  As Identifier ";" |
  
  Create ( Or Replace )? ( Secure )? Function Identifier  
  Returns ( Identifier | Table ( Identifier   ) )
  ( ( Not )? Null )?
  ( Language Javascript )?
  ( ( Called On Null Input | ( Returns Null On Null Input | Strict ) ) )?
  ( Volatile | Immutable )?
  ( Comment "="  Identifier  )?
  As  Identifier  ";" 
}



NameOp
{
  ( First_name "=" Identifier )? ( Last_name "=" Identifier )?
}

AccountOptional
{
  ( Region_group "=" Identifier )?  ( Region "=" Identifier )? ( Comment "="  Identifier  )?
}
ExFOp1
{
  ( ( Called On Null Input | ( Returns Null On Null Input | Strict ) ) )?
  ( Volatile | Immutable )?
  ( Comment "="  Identifier  )?

}
ExFOp2
{
  ( Headers "=" (  Identifier  "="  Identifier )+ )?
  ( Context_headers "=" ( Identifier  "," Identifier ) )?
  ( Max_batch_rows "=" NumberLiteral )?
  ( Compression "=" Identifier )?
}
EtOp
{
  ( Refresh_on_create "="  ( True | False ) )?
  ( Auto_refresh "=" ( True | False ) )?
  ( Pattern "="  Identifier  )?  
}

DbOp
{
  ( Data_retention_time_in_days "=" Identifier )?
  ( Max_data_extension_time_in_days "=" Identifier )?
  ( Default_ddl_collation "="  Identifier  )?
  ( Comment "="  Identifier  )?
}
DropStmt{

 Drop  (Table|User)  Identifier Smc

}

DescribeStmt{
  

  (Describe | Desc)  Table  Identifier (  Type  EqlSingle  (Stage| Columns )*)? Smc|
 (Describe | Desc)  Table  Identifier Smc |
  (Describe | Desc)  View  Identifier Smc |
  (Describe | Desc)  User  Identifier Smc |
  (Describe | Desc)  Network  Policy  Identifier Smc
}



ParenExpr {
  "(" Expr ")"
}


SubqueryExpr {
  Expr "[" Duration ":" ("" | Duration) "]"
}

UnaryExpr {
  !mul UnaryOp Expr
}

UnaryOp {
  "-" |
  "+"
}


LabelMatchers {
  "{" LabelMatchList "}" |
  "{" LabelMatchList "," "}" |
  "{" "}"
}

LabelMatchList {
  LabelMatchList "," LabelMatcher |
  LabelMatcher
}

MatchOp {
  EqlSingle |
  Neq |
  EqlRegex |
  NeqRegex
}

LabelMatcher {
  LabelName MatchOp StringLiteral
}

MetricIdentifier {
  Identifier
}

StepInvariantExpr {
  Expr At ( NumberLiteral | SignedNumber | AtModifierPreprocessors "(" ")" )
}

AtModifierPreprocessors {
  Start | End
}

SignedNumber{
  ("+" | "-" ) NumberLiteral
}

@skip { whitespace  | LineComment}



@tokens {
  whitespace { std.whitespace+ }
  LineComment { "#" ![\n]* }

  NumberLiteral {
   // ("+" | "-")? 
    (
      (std.digit+ ("." std.digit*)? | "." std.digit+) (("e" | "E") ("+" | "-")? std.digit+)? |
      "0x" (std.digit | $[a-fA-F])+ |
      $[nN]$[aA]$[nN] |
      $[iI]$[nN]$[fF]
    )
  }
  StringLiteral { // TODO: This is for JS, make this work for PromQL.
    '"' (![\\\n"] | "\\" _)* '"'? |
    "'" (![\\\n'] | "\\" _)* "'"? |
    "`" ![`]* "`"
  }

  Duration {
    // Each line below is just the same regex repeated over and over, but each time with one of the units made non-optional,
    // to ensure that at least one <number>+<unit> pair is provided and an empty string is not recognized as a valid duration.
    ( ( std.digit+ "y" ) ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" ) ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" ) ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" ) ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" ) ( std.digit+ "s" )? ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" ) ( std.digit+ "ms" )? ) |
    ( ( std.digit+ "y" )? ( std.digit+ "w" )? ( std.digit+ "d" )? ( std.digit+ "h" )? ( std.digit+ "m" )? ( std.digit+ "s" )? ( std.digit+ "ms" ) )
  }
  Identifier { ((std.asciiLetter|std.digit | "_" | ":") (std.asciiLetter* | std.digit* | "_" | ":"|"@"|"/"|"+"|"-"|"*"|"/"|"^"|"("|")"|">"|"<"|"%"|".")*)  }

  //Identifier { (std.asciiLetter | "_" | ":") (std.asciiLetter | std.digit | "_" | ":" )*}
  LabelName { (std.asciiLetter | "_") (std.asciiLetter | std.digit | "_")* }

  // Operator
  Smc {";"}
  Uscr {"_"}
  Dash {"-"} 
  //Star {"*"}
  Sub { "-" }
  Add { "+" }
  Mul { "*" }
  Mod { "%" }
  Div { "/" }
  Eql { "==" }
  Neq { "!=" }
  Lte { "<=" }
  Lss { "<" }
  Gte { ">=" }
  Gtr { ">" }
  Sqt {"'"}
  Cqt{"'"}
  EqlRegex { "=~" }
  EqlSingle { "=" }
  NeqRegex { "!~" }
  Pow { "^" }
  Opl {"("}
  Opr {")"}
  Dot {"."}

  //SQL
  Comma {","}

  // Special Modifier
  Atr { "@" }

  // Modifier Preprocessors
  Start { "start" }
  End { "end" }

  // To parse signed numbers into a number literal and not a unary expression.
  @precedence { NumberLiteral, "+", "-" }
  // To parse NaN/Inf as a number literal.
  @precedence { NumberLiteral, Identifier }
}



ArithExpr{
 "("? (NumberLiteral|Identifier)   (Add|Sub)  (NumberLiteral|Identifier) ")"? 

}




// Keywords

@external specialize {Identifier} specializeIdentifier from "./tokens" {
Account,Admin,Admin_name,Admin_password,Allowed_IP_List,And,Api,Api_allowed_prefixes,Api_aws_role_arn,Api_blocked_prefixes,Api_integration,Api_provider,As,At,Auto,Auto_refresh,
Auto_refresh_materialized_views_on_secondary,
Avro,Aws_api_gateway,Aws_private_api_gateway,Aws_sns_topic,Azure_ad_application_id,Azure_api_management,Azure_tenant_id,Before,Between,Blocked_IP_List,Bool,Brotli,Business,Business_critical,By,Bz2,Called,
Cascade,Change,Clone,Columns,Comment,Compression,Constraint,Context_headers,Copy,Create,Critical,Csv,Data_retention_time_in_days,Database,Default_ddl_collation,Deflate,Desc,Describe,Drop,Edition,Email,
Enabled,Enterprise,Escape,Exists,External,Externalstage,False,Field_delimiter,File,File_format,First,First_name,Foreign,Format,Format_name,From,Function,Grants,GroupLeft,GroupRight,Gzip,Headers,IP,
If,Ignoring,Immutable,In,Input,Integration,Is,Javascript,Json,Key,Language,Last,Last_name,Like,List,Location,Max_batch_rows,Max_data_extension_time_in_days,Must,Must_change_password,Name,Network,None,Not,Null,
Of,Offset,On,Or,Orc,Parquet,Partition,Password,Pattern,Policy,Primary,Raw_deflate,Record_delimiter,References,Refresh_on_create,Region,Region_group,Replace,Replica,Restrict,Returns,Role,Schema,Secure,Select,
Sequence,Share,Skip_blank_lines,Skip_header,Snappy,Stage,Standard,Statement,Strict,Table,Task,Timestamp,Transient,True,Type,Unique,User,View,Volatile,Warehouse,Where,With,Zstd

}

// Contextual keywords

/*@external extend {Identifier} extendIdentifier from "./tokens" {

 
  Count,
  Group,
  By,
  And
}*/


